namespace c = "http://www.w3.org/ns/xproc-step"
namespace local = ""
default namespace p = "http://www.w3.org/ns/xproc"
namespace s = "http://www.ascc.net/xml/schematron"
namespace sa = "http://xproc.org/ns/syntax-annotations"
namespace xs = "http://www.w3.org/2001/XMLSchema"

# This schema neither supports nor requires the use of RELAX NG DTD Compatibility
[ sa:model = "XPathExpression" ] XPathExpression = text
[ sa:model = "XSLTSelectionPattern" ] XSLTSelectionPattern = text
[ sa:model = "XPathSequenceType" ] XPathSequenceType = text
[ sa:model = "ContentType" ] ContentType = text
[ sa:model = "ContentTypes" ] ContentTypes = text
[ sa:model = "map(xs:QName,item())" ] PropertyMap = text
[ sa:model = "map(xs:QName,xs:anyAtomicValue)" ] SerializationMap = text
[ sa:model = "EQName*" ] ListOfEQName = text
[ sa:model = "char" ] Char = text
name.ncname.attr = attribute name { xsd:NCName }
name.qname.attr = attribute name { xsd:QName }
as.attr = attribute as { XPathSequenceType }
port.attr = attribute port { xsd:NCName }
required.attr = attribute required { xsd:boolean }
sequence.attr = attribute sequence { xsd:boolean }
primary.attr = attribute primary { xsd:boolean }
select.attr = attribute select { XPathExpression }
xpath-version.attr = attribute xpath-version { text }
psvi-required.attr = attribute psvi-required { xsd:boolean }
document-properties.attr = attribute document-properties { PropertyMap }
serialization.attr = attribute serialization { SerializationMap }
content-type.attr = attribute content-type { ContentType }
content-types.attr = attribute content-types { ContentTypes }
collection.attr = attribute collection { xsd:boolean }
pipe.attr = attribute pipe { text }
expand-text.attr = attribute expand-text { xsd:boolean }
exclude-inline-prefixes.attr =
  attribute exclude-inline-prefixes { ExcludeInlinePrefixes }
# Bah, humbug. The ExcludeInlinePrefixes pattern should 
# really be ("#all" | (PrefixList & "#default"?)) or
# maybe ("#all" | (PrefixList | "#default")+), but neither
# one of those is allowed by RELAX NG.
[ sa:model = "ExcludeInlinePrefixes" ] ExcludeInlinePrefixes = text
[ sa:model = "PrefixList" ] PrefixList = xsd:NMTOKENS
[ sa:model = "QNameList" ] QNameList = xsd:NMTOKENS
[ sa:ignore = "yes" ] xmlid.attr = attribute xml:id { xsd:ID }
[ sa:ignore = "yes" ] xmlbase.attr = attribute xml:base { xsd:anyURI }
href.attr = attribute href { xsd:anyURI }
[ sa:ignore = "yes" ]
use-when.attr = attribute use-when { XPathExpression }
[ sa:ignore = "yes" ]
p_use-when.attr = attribute p:use-when { XPathExpression }
version.attr = attribute version { "3.0" }
common.attributes = xmlid.attr?, xmlbase.attr?, extension.attr*
inline.attributes = exclude-inline-prefixes.attr?
decl.attributes =
  psvi-required.attr?,
  xpath-version.attr?,
  exclude-inline-prefixes.attr?,
  version.attr?,
  expand-text.attr?
# ============================================================
start =
  Library
  | DeclareStep
  | VocabParam
  | VocabParamSet
  | VocabResult
  | VocabHttpRequest
  | VocabHeader
  | VocabMultipart
  | VocabBody
  | VocabHttpResponse
  | VocabQuery
  | VocabLine
  | VocabData
  | VocabDirectory
  | Errors
  | StandardStep
  | ExtraStep
# StandardStep is explicitly unspecified because this is not a complete schema
ExtraStep = notAllowed
# ============================================================
[ sa:class = "language-construct" ]
Library =
  element library {
    decl.attributes,
    common.attributes,
    use-when.attr?,
    (Import | DeclareStep | Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
Import =
  element import {
    common.attributes,
    use-when.attr?,
    href.attr,
    (Documentation | PipeInfo)*
  }
[ sa:model = "subpipeline" ]
Subpipeline =
  (Variable
   | ForEach
   | Viewport
   | Choose
   | If
   | Group
   | Try
   | OtherStep
   | Documentation
   | PipeInfo)+
# ============================================================
[ sa:class = "language-construct" sa:element = "input" ]
Input =
  element input {
    port.attr,
    sequence.attr?,
    primary.attr?,
    select.attr?,
    content-types.attr?,
    [ sa:avt = "true" ] href.attr?,
    common.attributes,
    expand-text.attr?,
    inline.attributes,
    use-when.attr?,
    (((Empty | (Document | Inline)*)
      & (Documentation | PipeInfo)*)
     | AnyElement*)
  }
[ sa:class = "language-construct" sa:element = "with-input" ]
WithInput =
  element with-input {
    port.attr?,
    select.attr?,
    [ sa:avt = "true" ] href.attr?,
    pipe.attr?,
    common.attributes,
    expand-text.attr?,
    inline.attributes,
    use-when.attr?,
    (((Empty | (Document | Pipe | Inline)*)
      & (Documentation | PipeInfo)*)
     | AnyElement*)
  }
# ============================================================
[ sa:class = "language-construct" ]
OutputDeclaration =
  element output {
    port.attr?,
    sequence.attr?,
    primary.attr?,
    content-types.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    serialization.attr?,
    (Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
OutputConnection =
  element output {
    port.attr?,
    sequence.attr?,
    primary.attr?,
    content-types.attr?,
    serialization.attr?,
    [ sa:avt = "true" ] href.attr?,
    pipe.attr?,
    common.attributes,
    expand-text.attr?,
    inline.attributes,
    use-when.attr?,
    (((Empty | (Document | Pipe | Inline)*)
      & (Documentation | PipeInfo)*)
     | AnyElement*)
  }
[ sa:element = "output" ] Output = OutputDeclaration | OutputConnection
[ sa:class = "language-construct" ]
Pipe =
  element pipe {
    attribute step { xsd:NCName }?,
    port.attr?,
    common.attributes,
    use-when.attr?,
    (Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
Document =
  element document {
    [ sa:avt = "true" ] href.attr,
    attribute content-type { text }?,
    document-properties.attr?,
    attribute parameters { PropertyMap }?,
    common.attributes,
    use-when.attr?,
    (Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
Inline =
  element inline {
    common.attributes,
    inline.attributes,
    attribute content-type { text }?,
    document-properties.attr?,
    attribute encoding { text }?,
    use-when.attr?,
    expand-text.attr?,
    Any*
  }
[ sa:class = "language-construct" ]
Empty = element empty { (Documentation | PipeInfo)* }
# ============================================================
[ sa:class = "language-construct" ]
OptionDeclaration =
  element option {
    name.qname.attr,
    as.attr?,
    required.attr?,
    common.attributes,
    use-when.attr?,
    (Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
OptionSelect =
  element option {
    name.qname.attr,
    as.attr?,
    required.attr?,
    select.attr,
    common.attributes,
    use-when.attr?,
    (Documentation | PipeInfo)*
  }
[ sa:element = "option" ] Option = OptionDeclaration | OptionSelect
# ============================================================
[ sa:class = "language-construct" ]
WithOptionSelect =
  element with-option {
    name.qname.attr,
    as.attr?,
    select.attr,
    [ sa:avt = "true" ] collection.attr?,
    [ sa:avt = "true" ] href.attr?,
    pipe.attr?,
    common.attributes,
    expand-text.attr?,
    inline.attributes,
    use-when.attr?,
    (((Empty | (Document | Pipe | Inline)*)
      & (Documentation | PipeInfo)*)
     | AnyElement*)
  }
[ sa:element = "with-option" ] WithOption = WithOptionSelect
# ============================================================
[ sa:class = "language-construct" ]
VariableSelect =
  element variable {
    name.qname.attr,
    as.attr?,
    select.attr,
    [ sa:avt = "true" ] collection.attr?,
    [ sa:avt = "true" ] href.attr?,
    pipe.attr?,
    common.attributes,
    expand-text.attr?,
    inline.attributes,
    use-when.attr?,
    (((Empty | (Document | Pipe | Inline)*)
      & (Documentation | PipeInfo)*)
     | AnyElement*)
  }
[ sa:element = "variable" ] Variable = VariableSelect
# ============================================================
[ sa:class = "language-construct" ]
DeclareStep =
  element declare-step {
    name.ncname.attr?,
    attribute type { xsd:QName }?,
    decl.attributes,
    attribute visibility { "private" | "public" }?,
    common.attributes,
    use-when.attr?,
    (Input | Output | Option | Documentation | PipeInfo)*,
    ((DeclareStep | Import | Documentation | PipeInfo)*, Subpipeline)?
  }
# ============================================================
[ sa:class = "language-construct" ]
ForEach =
  element for-each {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((WithInput? & (Output | Documentation | PipeInfo)*),
     Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
Viewport =
  element viewport {
    name.ncname.attr?,
    [ sa:avt = "true" ] attribute match { XSLTSelectionPattern },
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((WithInput? & Output? & Documentation* & PipeInfo*), Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
Choose =
  element choose {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Documentation | PipeInfo)*,
     WithInput?,
     ((((Documentation | PipeInfo)*, When)+,
       ((Documentation | PipeInfo)*, Otherwise)?)
      | (((Documentation | PipeInfo)*, When)*,
         ((Documentation | PipeInfo)*, Otherwise))),
     (Documentation | PipeInfo)*)
  }
[ sa:class = "language-construct" ]
When =
  element when {
    attribute test { XPathExpression },
    [ sa:avt = "true" ] collection.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Documentation | PipeInfo)*,
     WithInput?,
     (Output | Documentation | PipeInfo)*,
     Subpipeline)
  }
[ sa:class = "language-construct" ]
Otherwise =
  element otherwise {
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Output | Documentation | PipeInfo)*, Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
If =
  element if {
    attribute test { XPathExpression },
    [ sa:avt = "true" ] collection.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Documentation | PipeInfo)*,
     WithInput?,
     (Output | Documentation | PipeInfo)*,
     Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
Group =
  element group {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Output | Documentation | PipeInfo)*, Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
Try =
  element try {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((TryGroup,
      ((Catch+, Finally?) | (Catch*, Finally)))
     & (Documentation | PipeInfo)*)
  }
[ sa:class = "language-construct" ]
TryGroup =
  element group {
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Output | Documentation | PipeInfo)*, Subpipeline)
  }
[ sa:class = "language-construct" ]
Catch =
  element catch {
    name.ncname.attr?,
    attribute code { QNameList }?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Output | Documentation | PipeInfo)*, Subpipeline)
  }
[ sa:class = "language-construct" ]
Finally =
  element finally {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    use-when.attr?,
    ((Documentation | PipeInfo)*, Subpipeline)
  }
# ============================================================
[ sa:class = "language-construct" ]
OtherAtomicStep =
  element * - p:* {
    name.ncname.attr?,
    option.attr*,
    common.attributes,
    expand-text.attr?,
    p_use-when.attr?,
    (WithInput | WithOption | Documentation | PipeInfo)*
  }
[ sa:class = "language-construct" ]
OtherCompoundStep =
  element * - p:* {
    name.ncname.attr?,
    common.attributes,
    expand-text.attr?,
    p_use-when.attr?,
    ((Output | Documentation | PipeInfo)*, Subpipeline)
  }
OtherStep = StandardStep | OtherAtomicStep | OtherCompoundStep
# ============================================================
[ sa:ignore = "yes" sa:class = "language-construct" ]
Documentation =
  element documentation {
    common.attributes, use-when.attr?, DocContent*
  }
[ sa:model = "any-well-formed-content" ] DocContent = Any
# ============================================================
[ sa:ignore = "yes" sa:class = "language-construct" ]
PipeInfo =
  element pipeinfo { common.attributes, use-when.attr?, DocContent* }
# ============================================================
_any.attr = attribute * { text }
option.attr = attribute local:* - (name | expand-text) { text }
extension.attr = attribute * - (local:* | xml:* | p:*) { text }
[ sa:model = "anyElement" ]
AnyElement = element * { (_any.attr | text | AnyElement)* }
[ sa:model = "anyNode" ]
Any =
  element * { (_any.attr | Any)* }
  | text
# ============================================================
[ sa:class = "step-vocabulary" ]
VocabParam =
  element c:param {
    name.qname.attr,
    attribute namespace { xsd:anyURI }?,
    attribute value { text },
    empty
  }
[ sa:class = "step-vocabulary" ]
VocabParamSet = element c:param-set { VocabParam* }
[ sa:class = "step-vocabulary" ]
VocabDirectory =
  element c:directory {
    attribute name { text },
    (VocabFile | VocabDirectory | VocabOther)*
  }
[ sa:class = "step-vocabulary" ]
VocabFile =
  element c:file {
    attribute name { text },
    content-types.attr?,
    empty
  }
[ sa:class = "step-vocabulary" ]
VocabOther =
  element c:other {
    attribute name { text },
    empty
  }
[ sa:class = "step-vocabulary" ] VocabResult = element c:result { text }
[ sa:class = "step-vocabulary" ]
VocabHttpRequest =
  element c:request {
    attribute method { xsd:NCName },
    attribute href { xsd:anyURI }?,
    attribute detailed { xsd:boolean }?,
    attribute status-only { xsd:boolean }?,
    attribute username { text }?,
    attribute password { text }?,
    attribute auth-method { text }?,
    attribute send-authorization { xsd:boolean }?,
    attribute override-content-type { ContentType }?,
    attribute timeout { xsd:positiveInteger }?,
    attribute fail-on-timeout { xsd:boolean }?,
    (VocabHeader*, (VocabMultipart | VocabBody)?)
  }
[ sa:class = "step-vocabulary" ]
VocabHeader =
  element c:header {
    attribute name { text },
    attribute value { text },
    empty
  }
[ sa:class = "step-vocabulary" ]
VocabMultipart =
  element c:multipart {
    content-type.attr,
    attribute boundary { text },
    VocabBody+
  }
[ sa:class = "step-vocabulary" ]
VocabBody =
  element c:body {
    content-type.attr,
    attribute encoding { text }?,
    attribute id { text }?,
    attribute description { text }?,
    attribute disposition { text }?,
    Any*
  }
[ sa:class = "step-vocabulary" ]
VocabHttpResponse =
  element c:response {
    attribute status { xsd:integer }?,
    (VocabHeader*, (VocabMultipart | VocabBody)?)
  }
[ sa:class = "step-vocabulary" ] VocabQuery = element c:query { text }
[ sa:class = "step-vocabulary" ] VocabLine = element c:line { text }
[ sa:class = "step-vocabulary" ]
VocabData =
  element c:data {
    content-type.attr,
    attribute charset { text }?,
    attribute encoding { text }?,
    text
  }
# ============================================================
[ sa:class = "error-vocabulary" ] Errors = element c:errors { Error* }
[ sa:class = "error-vocabulary" ]
Error =
  element c:error {
    name.ncname.attr?,
    attribute type { xsd:QName }?,
    attribute code { xsd:QName }?,
    attribute href { xsd:anyURI }?,
    attribute line { xsd:integer }?,
    attribute column { xsd:integer }?,
    attribute offset { xsd:integer }?,
    Any*
  }
Charset = text
Encoding = text
MIMEContentType = text
MIMEMediaType = text
RegularExpression = text
NormalizationForm =
  "NFC"
  | "NFD"
  | "NFKC"
  | "NFKD"
  | "fully-normalized"
  | "none"
  | xsd:NMTOKEN
ListOfQNames = text
StandardStep =
  Step-exec
  | Step-xsl-formatter
  | Step-add-attribute
  | Step-add-xml-base
  | Step-cast-content-type
  | Step-compare
  | Step-count
  | Step-delete
  | Step-directory-list
  | Step-error
  | Step-escape-markup
  | Step-filter
  | Step-hash
  | Step-http-request
  | Step-identity
  | Step-in-scope-names
  | Step-insert
  | Step-label-elements
  | Step-load
  | Step-make-absolute-uris
  | Step-namespace-rename
  | Step-pack
  | Step-parameters
  | Step-rename
  | Step-replace
  | Step-set-attributes
  | Step-set-properties
  | Step-sink
  | Step-split-sequence
  | Step-store
  | Step-string-replace
  | Step-unescape-markup
  | Step-unwrap
  | Step-uuid
  | Step-wrap-sequence
  | Step-wrap
  | Step-www-form-urldecode
  | Step-www-form-urlencode
  | Step-xinclude
  | Step-xslt
  | Step-validate-with-relax-ng
  | Step-validate-with-schematron
  | Step-validate-with-xml-schema
  | Step-xquery
Step-exec =
  element exec {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute command { xsd:string }?,
    attribute args { xsd:string }?,
    attribute cwd { xsd:string }?,
    attribute source-is-xml { xsd:boolean }?,
    attribute result-is-xml { xsd:boolean }?,
    attribute wrap-result-lines { xsd:boolean }?,
    attribute errors-is-xml { xsd:boolean }?,
    attribute wrap-error-lines { xsd:boolean }?,
    attribute path-separator { xsd:string }?,
    attribute failure-threshold { xsd:integer }?,
    attribute arg-separator { xsd:string }?,
    attribute serialization { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-xsl-formatter =
  element xsl-formatter {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute href { xsd:anyURI }?,
    attribute content-type { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-add-attribute =
  element add-attribute {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute attribute-name { xsd:QName }?,
    attribute attribute-prefix { xsd:NCName }?,
    attribute attribute-namespace { xsd:anyURI }?,
    attribute attribute-value { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-add-xml-base =
  element add-xml-base {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute all { xsd:boolean }?,
    attribute relative { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-cast-content-type =
  element cast-content-type {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute content-type { xsd:string }?,
    attribute parameters { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-compare =
  element compare {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute method { xsd:QName }?,
    attribute fail-if-not-equal { xsd:boolean }?,
    attribute parameters { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-count =
  element count {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute limit { xsd:integer }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-delete =
  element delete {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-directory-list =
  element directory-list {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute path { xsd:anyURI }?,
    attribute include-filter { RegularExpression }?,
    attribute exclude-filter { RegularExpression }?,
    (WithOption* & (Documentation | PipeInfo)*)
  }
Step-error =
  element error {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute code { xsd:QName }?,
    attribute code-prefix { xsd:NCName }?,
    attribute code-namespace { xsd:anyURI }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-escape-markup =
  element escape-markup {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute serialization { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-filter =
  element filter {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute select { XPathExpression }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-hash =
  element hash {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute value { xsd:string }?,
    attribute algorithm { xsd:QName }?,
    attribute match { XSLTSelectionPattern }?,
    attribute version { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-http-request =
  element http-request {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute serialization { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-identity =
  element identity {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    (WithInput* & (Documentation | PipeInfo)*)
  }
Step-in-scope-names =
  element in-scope-names {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    (Documentation | PipeInfo)*
  }
Step-insert =
  element insert {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute position {
      "first-child" | "last-child" | "before" | "after"
    }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-label-elements =
  element label-elements {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute attribute { xsd:QName }?,
    attribute attribute-prefix { xsd:NCName }?,
    attribute attribute-namespace { xsd:anyURI }?,
    attribute label { XPathExpression }?,
    attribute match { XSLTSelectionPattern }?,
    attribute replace { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-load =
  element load {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute href { xsd:anyURI }?,
    attribute parameters { xsd:string }?,
    attribute content-type { xsd:string }?,
    attribute document-properties { xsd:string }?,
    (WithOption* & (Documentation | PipeInfo)*)
  }
Step-make-absolute-uris =
  element make-absolute-uris {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute base-uri { xsd:anyURI }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-namespace-rename =
  element namespace-rename {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute from { xsd:anyURI }?,
    attribute to { xsd:anyURI }?,
    attribute apply-to { "all" | "elements" | "attributes" }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-pack =
  element pack {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute wrapper { xsd:QName }?,
    attribute wrapper-prefix { xsd:NCName }?,
    attribute wrapper-namespace { xsd:anyURI }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-parameters =
  element parameters {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    (WithOption* & (Documentation | PipeInfo)*)
  }
Step-rename =
  element rename {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute new-name { xsd:QName }?,
    attribute new-prefix { xsd:NCName }?,
    attribute new-namespace { xsd:anyURI }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-replace =
  element replace {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-set-attributes =
  element set-attributes {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-set-properties =
  element set-properties {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute properties { xsd:string }?,
    attribute merge { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-sink =
  element sink {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    (WithInput* & (Documentation | PipeInfo)*)
  }
Step-split-sequence =
  element split-sequence {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute initial-only { xsd:boolean }?,
    attribute test { XPathExpression }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-store =
  element store {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute href { xsd:anyURI }?,
    attribute serialization { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-string-replace =
  element string-replace {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute replace { XPathExpression }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-unescape-markup =
  element unescape-markup {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute namespace { xsd:anyURI }?,
    attribute content-type { xsd:string }?,
    attribute encoding { xsd:string }?,
    attribute charset { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-unwrap =
  element unwrap {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-uuid =
  element uuid {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute match { XSLTSelectionPattern }?,
    attribute version { xsd:integer }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-wrap-sequence =
  element wrap-sequence {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute wrapper { xsd:QName }?,
    attribute wrapper-prefix { xsd:NCName }?,
    attribute wrapper-namespace { xsd:anyURI }?,
    attribute group-adjacent { XPathExpression }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-wrap =
  element wrap {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute wrapper { xsd:QName }?,
    attribute wrapper-prefix { xsd:NCName }?,
    attribute wrapper-namespace { xsd:anyURI }?,
    attribute match { XSLTSelectionPattern }?,
    attribute group-adjacent { XPathExpression }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-www-form-urldecode =
  element www-form-urldecode {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute value { xsd:string }?,
    (WithOption* & (Documentation | PipeInfo)*)
  }
Step-www-form-urlencode =
  element www-form-urlencode {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute match { XSLTSelectionPattern }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-xinclude =
  element xinclude {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute fixup-xml-base { xsd:boolean }?,
    attribute fixup-xml-lang { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-xslt =
  element xslt {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute initial-mode { xsd:QName }?,
    attribute template-name { xsd:QName }?,
    attribute output-base-uri { xsd:anyURI }?,
    attribute version { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-validate-with-relax-ng =
  element validate-with-relax-ng {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute dtd-attribute-values { xsd:boolean }?,
    attribute dtd-id-idref-warnings { xsd:boolean }?,
    attribute assert-valid { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-validate-with-schematron =
  element validate-with-schematron {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute phase { xsd:string }?,
    attribute assert-valid { xsd:boolean }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-validate-with-xml-schema =
  element validate-with-xml-schema {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute use-location-hints { xsd:boolean }?,
    attribute try-namespaces { xsd:boolean }?,
    attribute assert-valid { xsd:boolean }?,
    attribute mode { "strict" | "lax" }?,
    attribute version { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
Step-xquery =
  element xquery {
    name.ncname.attr?,
    common.attributes,
    use-when.attr?,
    attribute parameters { xsd:string }?,
    attribute version { xsd:string }?,
    (WithInput* & WithOption* & (Documentation | PipeInfo)*)
  }
